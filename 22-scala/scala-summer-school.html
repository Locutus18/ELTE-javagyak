<h1>Segédanyagok</h1>

<ul>
<li>Az elõadás anyagai letölthetõk az alábbi linken: <a href="http://">xxx.tgz</a></li>
<li>Fejlesztõkörnyezet letöltése
<ul>
<li>Scala IDE, valamint a szükséges Java futtatókörnyezet egyben letölthetõ az alábbi linken: <a href="http://...">xxx.tgz</a></li>
<li>A fejlesztõkörnyezetrõl további információ az alábbi oldalon található: http://scala-ide.org/</li>
</ul></li>
<li>Scala weboldala: http://www.scala-lang.org/</li>
<li>Közösségi Scala dokumentációs project (tutorialok, Scala Improvement Process, Language Specification, stb.): http://docs.scala-lang.org/</li>
<li><p>Scaladoc online böngészhetõ, legfrissebb változata: http://www.scala-lang.org/api/current/index.html</p></li>
<li><p>Ajánlott olvasmányok (igyenesen elérhetõ könyvek):</p>

<ul>
<li>Joshua D. Suereth: <a href="http://typesafe.com/resources/scala-in-depth">Scala in Depth</a></li>
<li>Cay S. Horstmann: <a href="http://typesafe.com/resources/scala-for-the-impatient">Scala for the Impatient</a></li>
<li>Dean Wampler, Alex Payne: <a href="http://ofps.oreilly.com/titles/9780596155957/">Programming Scala</a></li>
</ul></li>
</ul>

<h1>Feladatok</h1>

<p>Megjegyzések:</p>

<ul>
<li>Az alábbi feladatok fõként <a href="http://aperiodic.net/phil/">Phil Gold</a>: <a href="http://aperiodic.net/phil/scala/s-99/">S-99 - Ninety-Nine Scala Problems</a> írásán alapszanak, amely valójában Werner Hett (Berne University of Applied Sciences) <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">Ninety-Nine Prolog Problems</a> mûvének egy adaptációja. Ha a feladatok túl nehezek, könnyûek, esetleg kevésbé izgalmasak, a fenti oldalakon bõven találhatók alternatívák.</li>
</ul>

<h2>Könnyebb feladatok</h2>

<p>Az alábbiakban egyszerûbb feladatok találhatók, amelyek nagyjából 15-20 perc alatt megoldhatók. Az elsõ feladatoknál még konkrét szignatúrát is megadunk, késõbb azonban ezt fokozatosan elhagyjuk, ezt is nektek kell helyesen megírnotok.</p>

<h3>Lista utolsó elemének meghatározása</h3>

<p>Készíts egy függvényt a következõ szignatúrával:</p>

<p><code>scala
def last[A](ls: List[A]): A
</code></p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; last(List(1, 1, 2, 3, 5, 8))
res0: Int = 8
</code></p>

<p>A megvalósításhoz ne a beépített függvényt használd, hanem próbáld a <code>match</code>, <code>::</code> operátor és üres lista (<code>Nil</code>) segítségével megoldani a feladatot!</p>

<h3>Lista végétõl számított N. elem meghatározása</h3>

<p>Készíts egy függvényt a következõ szignatúrával:</p>

<p><code>scala
def lastNth[A](n: Int, ls: List[A]): A
</code></p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; lastNth(2, List(1, 1, 2, 3, 5, 8))
res0: Int = 5
</code></p>

<p>A megvalósításhoz ne a beépített függvényt használd, hanem adj egy rekurzív algoritmust rá!</p>

<h3>Lista hosszának meghatározása</h3>

<p>Készíts egy függvényt a következõ szignatúrával:</p>

<p><code>scala
def length[A](ls: List[A]): Int
</code></p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; length(List(1, 3, 5, 7))
res0: Int = 4
</code></p>

<p>A megvalósításhoz ne a beépített függvényt használd, hanem vagy készíts egy végzõdés szerinti rekurziót (<em>tail recursion</em>), vagy használd valamely <code>fold()</code> függvényt!</p>

<h3>Stringek nagybetûssé alakítása</h3>

<p>Készíts egy függvényt, amely tetszõleges számú String paramétert elfogad (<em>nem listát!</em>), és minden paramétert nagybetûssé alakít!</p>

<p>A függvényt tedd egy megfelelõ <code>object</code> definícióba, valamint használd a megoldáshoz a <code>_</code> alapértelmezett paraméterjelölést!</p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; Upper.upper("A", "First", "Scala", "Program"))
res0: Array(A, FIRST, SCALA, PROGRAM)
</code></p>

<h3>String lista összefûzése egyetlen karakterlánccá</h3>

<p>Készíts egy függvényt a következõ szignatúrával:</p>

<p><code>scala
def joiner(strings: List[String], separator: String): String
</code></p>

<p>A separator paraméter alapértelmezett értékkel is rendelkezzen, ez legyen a szóköz karakter (<em>ehhez a megadott szignatúrát is módosíthatod, ha szükséges</em>)!</p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; joiner(List("Programming", "Scala"))
res0: String = "Programming Scala"
</code></p>

<h3>Stringek párosítása a hosszukkal</h3>

<p>Készíts egy függvényt a következõ szignatúrával, amely egy String listához visszaad olyan párokat, amelyek tartalmazzák az adott Stringet valamint annak a hozsszát:</p>

<p><code>scala
def sizes(ls: List[String]): List[(Int, String)]
</code></p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; sizes(List("a", "bc", "def"))
res0: List[(Int, String)] = List((1,a), (2,bc), (3,def))
</code></p>

<h3>Folding</h3>

<p>Készítsd el a következõ függvények definícióit, amelyekhez használd valamelyik <code>fold()</code> függvényt!</p>

<p>```scala
// Elemek osszege
def sum(list: List[Int]): Int</p>

<p>// Elemek szorzata
def product(list: List[Int]): Int</p>

<p>// Elemek szama
def count(list: List[Any]): Int</p>

<p>// Elemek atlaga
def average(list: List[Double]): Double
```</p>

<h3>Reducing</h3>

<p>Készítsd el a következõ függvények definícióit, amelyekhez használd valamelyik <code>reduce()</code> függvényt!</p>

<p>```scala
// Legkisebb elem meghatarozasa
scala> minOf(List(1,2,3))
res0: Int = 1</p>

<p>// Legnagyobb elem meghatarozasa
scala> maxOf(List(1,2,3))
res0: Int = 3
```</p>

<h2>Közepesen nehéz feladatok</h2>

<p>Az alábbi feladatok már kicsit bonyolultabbak, az elõadás anyagának aktív tanulmányozása szükséges a megoldásukhoz.</p>

<h3>Companion objektumok</h3>

<p>Készíts egy egyszerû <code>Pair</code> osztálydefiníciót, amely String párok elõállítására alkalmazható! Ennek egyetlen függvénye legyen:</p>

<p><code>scala
def value(): String
</code></p>

<p>Amely egy <code>new Pair("key", "value")</code> esetén adja vissza a <code>"key = value"</code> karakterláncot!</p>

<p>Készíts továbbá egy <em>companion objektumot</em> is az osztálydefinícióhoz, amely tegye lehetõvé a következõ használatot:</p>

<p><code>scala
val p = Pair("a", "b") // Nota bene: Nem szerepel 'new' operator!
</code></p>

<h3>Karakterkombinációk elõállítása</h3>

<p>Készíts egy olyan függvényt, amely a megadott String karaktereinek minden lehetséges permutációját elõállítja!</p>

<p>Példa a használatra:</p>

<p><code>scala
scala&gt; perm("abc")
res0: List[String] = List("abc", "acb", "bac", "bca", "cab", "cba")
</code></p>

<h3>Egybeágyazott listák kiegyenesítése</h3>

<p><code>scala
scala&gt; flatten(List(List(1, 1), 2, List(3, List(5, 8))))
res0: List[Any] = List(1, 1, 2, 3, 5, 8)
</code></p>

<p>A megvalósításhoz használd a <code>flatMap()</code> függvényt!</p>

<h3>Euklideszi algoritmus</h3>

<p><code>scala
scala&gt; gcd(36, 63)
res0: Int = 9
</code></p>

<p>A megvalósításhoz használd az euklideszi algoritmust!</p>

<h3>Relatív prímek</h3>

<p>Döntsük el két számról, hogy relatív prímek-e!</p>

<p><code>scala
scala&gt; 35.isCoprimeTo(64)
res0: Boolean = true
</code></p>

<p><strong>Megjegyzés</strong> Vegyük észre, hogy a függvényt a fenti módon egy tetszõleges számon hívjuk!</p>

<h3>Mintaillesztés reguláris kifejezésekkel</h3>

<p>Legyen adott a következõ lista definíció:</p>

<p><code>scala
val catalog = List(
  "Book: title=Programming Scala, authors=Dean Wampler, Alex Payne",
  "Magazine: title=The New Yorker, issue=January 2009",
  "Book: title=War and Peace, authors=Leo Tolstoy",
  "Magazine: title=The Atlantic, issue=February 2009",
  "BadData: text=Who put this here??"
)
</code></p>

<p>A lista bejárása során írjuk ki a képernyõre minden könyv (és csak azok!) címét, valamint íróját (de csak azokat!). A megoldáshoz használjunk mintaillesztést reguláris kifejezésekre!</p>

<h3>Kódolás</h3>

<p>Készítsünk egy nagyon egyszerû monoalfabetikus (egy karaktert mindig ugyanazzal a másik karakterrel helyettesítõ) kódoló rendszert, amelyet maga Caesar is használt! A kódolás lényege, hogy minden karaktert a tõle három karakterrel jobbra szereplõvel ábrázolunk.</p>

<p>Példa:</p>

<p><code>scala
scala&gt; encode("Alea iacta est")
res0: String="dohd ldfwd hvw"
</code></p>

<p>Kódolás elõtt minden karaktert alakítsunk kisbetûssé, valamint elég csupán az angol ABC karaktereivel foglalkozni!</p>

<p>Részletek a kódolás történetérõl a <a href="http://en.wikipedia.org/wiki/Caesar_cipher">Wikipédiában</a>.</p>

<h2>Nehéz feladatok</h2>

<p>Az alábbi feladatok már esetleg némi utánajárást vagy komolyabb gondolkodni valót jelentenek.</p>

<h3>Java könyvtárak használata</h3>

<p>Töltsd le az <a href="http://itextpdf.com">iText</a> könyvtárat, amely egy standard Java könyvtár. Használd az API-t Scalaból, és készíts egy egyszerû PDF formátumú fájlt a segítségével!</p>

<p>Egy egyszerû <a href="http://itextpdf.com/examples/iia.php?id=12">tutorial</a>, amely a használatot mutatja.</p>

<p>A program a készített PDF tartalmát olvassa egy fájlból!</p>

<h3>A lovag útja</h3>

<p>Adott egy <code>NxN</code> méretû sakktábla. Létezik-e olyan lépéssorozat, amely során egy ló bábúval minden sakktábla mezõt érinthetünk egy megadott kezdõpontról indulva?</p>

<p><strong>Továbbfejlesztési lehetõség</strong> Létezik-e ugyanilyen <em>zárt út</em> (zárt út egy olyan út, amely során az utolsó lépésben visszatérünk a kezdõpozícióra)?</p>

<p>Részletek a problémáról <a href="http://en.wikipedia.org/wiki/Knight's_tour">Wikipédiában</a>.</p>

<h3>Google Code Jam feladatok</h3>

<p>Ha kicsit izgalmasabb feladatokat szeretnél, az alábbi weboldalon <a href="http://code.google.com/codejam/contest/1460488/dashboard">a hivatalos Google Code Jam selejtezõ feladatait</a> is megpróbálhatod ;-)</p>
